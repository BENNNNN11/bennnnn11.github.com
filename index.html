<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-数据结构学习笔记-串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T01:07:52.000Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%B2/">数据结构学习笔记-串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h2><ul>
<li><p>定长顺序存储表示（静态存储）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 256</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> data[MAXLEN+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125; SString;</span><br></pre></td></tr></table></figure></li>
<li><p>堆分配存储表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 256</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *data;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125; HString;</span><br></pre></td></tr></table></figure></li>
<li><p>串的块链存储结构：整个串采用链式存储结构表示。每个节点既可以存放一个字符也可以存放多个字符，如果存放多个字符，则可以看作为块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE <span class="meta-string">&lt;长度&gt;</span> <span class="comment">// 如果单词长度占不满则补“#”</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> &#123;</span> <span class="comment">// 块节点</span></span><br><span class="line">  <span class="keyword">char</span> data[CHUNKSIZE];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  Chunk *head, *tail; <span class="comment">// 头尾节点</span></span><br><span class="line">  <span class="keyword">int</span> curlen; <span class="comment">// 当前长度</span></span><br><span class="line">&#125; LString;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="串操作"><a href="#串操作" class="headerlink" title="串操作"></a>串操作</h2><ul>
<li><p>字符串拼接    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Concat</span><span class="params">(SString &amp;T, SString &amp;S1, SString &amp;S2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (S1.length + S2.length &lt;= MAXSIZE) &#123;  <span class="comment">// 未截断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S1.length; i++) T.data[i] = S1.data[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S2.length; i++) T.data[i+S1.length] = S2.data[i];	</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S1.length &lt; MAXSIZE) &#123; <span class="comment">// 截断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S1.length; i++) T.data[i] = S1.data[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = S1.length; i &lt; MAXSIZE; i++) T.data[i] = S2.data[i - S2.length];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 截断仅s1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++) T.data[i] = S1.data[i];</span><br><span class="line">    T.length = MAXSIZE;</span><br><span class="line">   	<span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求子字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SubStr</span><span class="params">(SString &amp;sub, SString s, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 用sub返回字符串s第pos个字符其长度为len的子串</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">1</span> || pos &gt; s.length || len &gt; (s.length - pos + <span class="number">1</span>) || len &lt; <span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    sub-&gt;data[i] = s.data[pos - <span class="number">1</span> + i];</span><br><span class="line">  &#125;</span><br><span class="line">  sub-&gt;length = len;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SubStr</span><span class="params">(SString &amp;s, SString t, <span class="keyword">int</span> pos)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 在pos之前插入串t</span></span><br><span class="line">	<span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt; s.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span> (s.length + t.length &lt;= MAXSIZE) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length; i &gt;= pos; i--) s.data[i + t.length] = s.data[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length; i++) s.data[pos + i] = t.data[i];</span><br><span class="line">    s.length += t.length;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrDelete</span><span class="params">(SString &amp;s, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos + len - <span class="number">1</span> &gt; s.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="comment">// 删除后面的元素前移</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + len; i &lt;= s.length; i++) &#123;</span><br><span class="line">    s.data[i - len] = s.data[i];</span><br><span class="line">    s.length -= len;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h2><ul>
<li><p>子串定位算法(简单匹配法)：从主串的第pos个字符起和模式串的一个字符比较，若相等，则继续比较后续字符，若不相等则回溯，从主串的下一个字符起再重新和模式的字符比较。依次类推，直到模式串中每一个字符依次和主串中的连续字符相等。返回模式串的第一个字符在主串中的索引。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrIndex</span><span class="params">(SString s, <span class="keyword">int</span> pos, SString t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">if</span> (t.length == <span class="number">0</span> || pos &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  i = pos, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; t.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.data[i] == t.data[j]) &#123;i++; j++;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      i = i - j + <span class="number">1</span>;</span><br><span class="line">      j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j &gt;= t.length) <span class="keyword">return</span> i - j;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n + m) , n 和 m分别为主串和模式串的长度， 最坏情况下为O(n*m), 如主串为0000000000000000000001，模式串为000001</li>
</ul>
</li>
<li><p><strong>KMP算法</strong>： 不需要回溯，而是每当一趟匹配过程中字符比较不相等时，不需要回溯i指针，而是利用已经得到的“部分匹配”的结果将模式向右滑动尽可能远的一段距离。</p>
<ul>
<li><p>next表：所谓next[j], 即在P[0, j)中，自匹配的<strong>真前缀</strong>和<strong>真后缀</strong>的最大长度</p>
<ul>
<li><p>构建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">buildNext</span><span class="params">(<span class="keyword">char</span> *P)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> m = <span class="built_in">strlen</span>(P), j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> *N = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">// next表</span></span><br><span class="line">  <span class="keyword">int</span> t = N[<span class="number">0</span>] = <span class="number">-1</span>; </span><br><span class="line">  <span class="keyword">while</span> (j &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; t || P[j] == [t]) &#123;</span><br><span class="line">      ++j; ++t;</span><br><span class="line">      N[j] = P[j] != P[t] ? t : N[t];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      t = N[t];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *P, <span class="keyword">char</span> *T)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *next = <span class="built_in">buildNext</span>(P); <span class="comment">// 构造查询表</span></span><br><span class="line">  <span class="keyword">int</span> n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(T), i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> m = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(P), j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || T[i] == P[j]) &#123;</span><br><span class="line">      i++; j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> [] next;</span><br><span class="line">  <span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n), n为文本串长度</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%B2/" data-id="cks72bhe50000zh8n6obqetdd" data-title="数据结构学习笔记-串" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-排序总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/10/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-08-10T00:44:46.000Z" itemprop="datePublished">2021-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/10/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/">排序总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>基于比较：<ul>
<li>基于比较的排序<ul>
<li>插入排序：<ul>
<li>简单插入排序，希尔排序</li>
</ul>
</li>
<li>交换排序： <ul>
<li>冒泡排序，快排排序</li>
</ul>
</li>
<li>选择排序：<ul>
<li>简单选择排序，堆排序</li>
</ul>
</li>
<li>归并排序：二路，多路</li>
</ul>
</li>
<li>非比较排序<ul>
<li>基数排序/计数排序，桶排序</li>
</ul>
</li>
</ul>
</li>
<li>基于稳定性： 稳定性是指假设在待排序的序列中，存在多个具有相同关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j], 且r[i] 在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则这种算法称为是稳定的，否则为非稳定的<ul>
<li>稳定排序：    <ul>
<li>冒泡排序，插入排序，归并排序，基数排序， 计数排序，桶排序</li>
</ul>
</li>
<li>非稳定排序：<ul>
<li>选择排序，希尔排序，快速排序，堆排序</li>
</ul>
</li>
</ul>
</li>
<li>基于内部和外部：<ul>
<li>若待排序的记录全部在内存中，则称为内排序</li>
<li>若待排序的记录一部分在内存中，一部分在外存中，称为外部排序</li>
<li>内部排序：<ul>
<li>插入排序（希尔排序）</li>
<li>交换排序（冒泡排序，快速排序）</li>
<li>选择排序（堆排序）</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>内部排序</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>内部排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>内部排序</td>
<td>稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>内部排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(logn)</td>
<td>内部排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>内部排序</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1.5)</td>
<td></td>
<td></td>
<td>O(1)</td>
<td>内部排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>计数排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>桶排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol>
<li><p><strong>插入排序</strong>：每次将一个待排序的对象，按其关键码的大小，插入到前面已经排好序的一组对象的适当的位置上，直到对象全部插入为止。</p>
<ul>
<li><p><strong>直接插入排序</strong>：</p>
<ul>
<li><p>顺次地从无序表中取出记录Ri（1 &lt;= i &lt;= n）, 与有序表中记录的关键字逐个进行比较，找出其应该插入的位置</p>
</li>
<li><p>将此位置即其之后的所有记录依次向后顺移一个位置</p>
</li>
<li><p>将记录Ri插入到空出的位置上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采取顺序结构，定义如下</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  KeyType key;</span><br><span class="line">  InfoType otherinfo;</span><br><span class="line">&#125; RecordType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  RecordType r[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设将n个待排序的记录顺序的存放在长度为n+1的数组R[1]到R[n]中</span></span><br><span class="line"><span class="comment">// R[0]作为辅助空间，用来暂时存放需要插入的记录，起到监视哨的作用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= L.length; i++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (L.r[i].key &lt; L.r[i - <span class="number">1</span>].key) &#123; <span class="comment">// 找到需要排序的节点</span></span><br><span class="line">      L.r[<span class="number">0</span>] = L.r[i]; <span class="comment">// 存储为哨兵节点</span></span><br><span class="line">      <span class="keyword">for</span> (j = i - <span class="number">1</span>; L.r[<span class="number">0</span>].key &lt; L.r[j].key; j--) &#123;</span><br><span class="line">        L.r[j + <span class="number">1</span>] = L.r[j]; <span class="comment">// 移动记录</span></span><br><span class="line">      &#125;</span><br><span class="line">      L.r[j + <span class="number">1</span>] = L.r[<span class="number">0</span>]; <span class="comment">// 插入到正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析： </p>
<ul>
<li>外层for循环执行n-1次，每次循环中的操作是比较和移动，总次数取决于数据表的初始特性<ul>
<li>最好的情况: 当初始记录序列的关键字是递增排列时, O(n)</li>
<li>最坏的情况：当初始记录序列的关键字是递减排列时， O(n^2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>折半插入排序</strong></p>
<ul>
<li><p>在插入R[i]时（此时R[1] … R[i - 1]已经排好序）， 取R[floor(i/2)]的关键字与R[i]的关键字进行比较。</p>
</li>
<li><p>如果R[floor(i/2)]的关键字大于R[i]的关键字，R[i]的插入位置只能在R[1]到R[floor(i/2)]之间，则在R[1]到R[floor(i/2)]之间继续进行折半查找</p>
</li>
<li><p>否则，在R[floor(i/2)  + 1]到R[i - 1]之间继续进行折半查找</p>
</li>
<li><p>如此反复直到找到插入位置为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, high, low, m;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= L.length; i++) &#123;</span><br><span class="line">    L.r[<span class="number">0</span>] = L.r[i]; <span class="comment">// 存储为哨兵节点</span></span><br><span class="line">    low = <span class="number">1</span>; high = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123; <span class="comment">// 在r[low..high]中折半查找有序插入的位置</span></span><br><span class="line">      m = (low + high) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (L.r[<span class="number">0</span>].key &lt; L.r[m].key) high = m - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> low = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--) &#123; <span class="comment">// 后移</span></span><br><span class="line">      L.r[j + <span class="number">1</span>] = L.r[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[high + <span class="number">1</span>] = L.r[<span class="number">0</span>]; <span class="comment">// 插入</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>复杂度分析：</p>
<ul>
<li>比较次数减为O(nlogn)，但是移动次数并未减少，依旧为O(n^2)</li>
</ul>
</li>
<li><p>followup：若记录是链表，可否用直接插入，可否用折半插入？</p>
<ul>
<li>直接插入可行并且不需要移动元素</li>
<li>但是链表没法折半，无法用折半插入</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>希尔排序</strong>：先将整个待排记录序列分割成若干个子序列，分别在组内进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录再进行一次直接插入排序</p>
<ul>
<li>取一个整数d1 &lt; n， 称为增量， 将待排的记录分为d1个组，凡是距离为d1倍数的记录都放在一个组里，在各组内进行直接插入排序。这样做一次分组并排序的过程称为一趟希尔排序。</li>
<li>再设置另一个新的增量d2 &lt; d1， 采取上述相同的方法继续分组和排序</li>
<li>继续取di+1&lt; di, 重复步骤二，直到增量为1，即所有的记录都放在一个组里。</li>
</ul>
<p>![截屏2021-08-10 下午1.02.00](/Users/oukeakira/Library/Application Support/typora-user-images/截屏2021-08-10 下午1.02.00.png)</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> dk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = dk + <span class="number">1</span>; i &lt;= L.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L.r[i].key &gt; L.r[i - dk].key) &#123;</span><br><span class="line">      L.r[<span class="number">0</span>] = L.r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; L.r[<span class="number">0</span>].key &lt; L.r[j].key; j -= dk) &#123;</span><br><span class="line">      L.r[j + dk] = L.r[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[j + dk] = L.r[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>交换排序</strong>： 两两比较待排序记录的关键码，如果发生逆序 (即排列顺序与排序后的次序正好相反)，则交换之，直到所有记录都排好序为止。</p>
<ul>
<li><p><strong>冒泡排序</strong>： 每趟不断将记录两两比较，并按“前小后大” (或“前大后小”)规则交换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= L.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (L.r[j].key &gt; L.r[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        L.r[<span class="number">0</span>] = L.r[j];</span><br><span class="line">        L.r[j] = L.r[j + <span class="number">1</span>];</span><br><span class="line">        L.r[j + <span class="number">1</span>] = L.r[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最好情况：初始排列已经有序，O(n)</li>
<li>最坏情况：初始排列已经逆序，O(n^2)</li>
<li>平均情况：O(n^2)</li>
<li>空间效率：O(1)</li>
<li>稳定性：稳定</li>
</ul>
</li>
<li><p><strong>快速排序</strong>：</p>
<ul>
<li>从待排序列中任取一个记录Ri作为基准（通常取序列的第一个记录），将所有的记录分为两个序列分组，使得排在Ri之前的序列的记录关键字都小于基准的关键字，排在Ri之后的序列的记录关键字都大于基准的关键字。此时基准Ri的位置就是它最终的排序位置。此过程为一趟快速排序。</li>
<li>然后分别对左右两个序列重复上述过程，直到所有记录都排在相应的位置上为止。</li>
<li>选基准的方式：<ul>
<li>选序列第一个记录</li>
<li>选序列中间位置的记录</li>
<li>比较首端，中间端，终端位置上的记录的关键字大小，选三个值中居中的记录作为基准</li>
</ul>
</li>
<li>比较和交换是从待排序列的两端向中间进行的。设置两个变量low，high，初始值分别表示待排序列的第一个记录和最后一个记录。设中枢记录的关键字为pivotKey<ul>
<li>从序列的最后位置的记录Rj开始依次向前扫描，若存在pivotKey&lt;=Rj.key, 则high–; 直到pivotKey&gt;Rj.key或者high=low时为止。若low&lt;high，将比枢轴记录小的记录移到低端。</li>
<li>从序列的开始位置的记录Ri开始依次向后扫描，若存在pivotKey&gt;=Ri.key, 则low++; 直到pivotKey&lt;Ri.key或者high=low时为止。若low&lt;high，将比枢轴记录大的记录移到高端。</li>
</ul>
</li>
</ul>
<p>​    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">  KeyType pivotkey;</span><br><span class="line">  L.r[<span class="number">0</span>] = L.r[low];</span><br><span class="line">  pivotkey = L.r[<span class="number">0</span>].key;</span><br><span class="line">  <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey) high--;</span><br><span class="line">    L.r[low] = L.r[high];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey) low++; </span><br><span class="line">    L.r[high] = L.r[low];</span><br><span class="line">  &#125;</span><br><span class="line">  L.r[low] = L.r[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>复杂度分析：</p>
<ul>
<li><p>在理想情况下，每次排序时所选取的记录关键字值都是当前待排序列中的“中值”记录，那么该记录的排序终止位置应在 该序列的中间，这样就把原来的子序列分解成了两个长度大致 相等的更小的子序列，在这种情况下，排序的速度最快。整个算法的时间复杂度为O(nlogn)。</p>
</li>
<li><p>在极端情况下，即每次选取的“基准”都是当前分组序列中关 键字最小(或最大)的值，划分的结果是基准的前边(或右边)为空， 即把原来的分组序列分解成一个空序列和一个长度为原来序列 长度减1的子序列。整个算法的时间复杂度为O(n2)。</p>
</li>
<li><p>一般情况下，序列中各记录关键字的分布是随机的，因而可以 认为快速排序算法的平均时间复杂度为<strong>O(nlog2n)<strong>。实验证明，当</strong>n</strong> 较大时，快速排序是目前被认为最好的一种内部排序方法。</p>
</li>
<li><p>在算法实现中需<strong>设置一个栈的存贮空间来实现递归</strong>，栈的大小取决于递归深度，最多不会超过<strong>n</strong>。若每次都选较长的分组序列进栈， 而处理较短的分组序列，则递归深度最多不会超过<strong>log2n</strong>，因此快 速排序需要的辅助存贮空间为<strong>O(log2n)</strong></p>
</li>
<li><p>快速排序算法是不稳定排序，对于有相同关键字的记录，排序后有可能颠倒位置。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>选择排序</strong>：不断从待排序列中选出关键字最小的记录插入到已排序的序列后面，直到n个记录全部插入已排序记录序列中。</p>
<ul>
<li><p><strong>简单选择排序</strong>：</p>
<ul>
<li><p>从待排记录序列中选出关键字最小的记录与第一个位置的数交换;</p>
</li>
<li><p>然后在剩下的数中找最小的与第二个数交换，以此类推</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, k;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 在[i...L.length]中选择最小的记录</span></span><br><span class="line">    k = i;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (L.r[j].key &lt; L.r[k].key) k = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k != i) &#123;</span><br><span class="line">      KeyType temp = L.r[i];</span><br><span class="line">      L.r[i] = L.r[k];</span><br><span class="line">      L.r[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析：<ul>
<li>假定整个序列表有<strong>n</strong>个记录，总共需要<strong>n-1</strong>趟的选择;</li>
<li>第<strong>i</strong> 趟选择具有最小关键字记录所需要的<strong>比较次数</strong>是<strong>n-i-1</strong> 次，总的关键字比较次数为:<strong>（n-1)+(n-2)+…+1=n(n-1)/2</strong></li>
<li>交换次数：最坏的情况是每一趟选择后都要进行交换，一趟交换需 要移动记录<strong>3</strong>次。总的记录移动次数为**3(n-1)**。</li>
<li>所以简单选择排序的时间复杂度为O(n^2)</li>
<li>只需要一个临时单元用作交换，因此 空间复杂度为<strong>O(1)</strong></li>
<li>存在不相邻记录之间的互换， 可能会改变具有相同关键字记录的相对位置，所以该算法是不稳定排序。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>树形选择排序：首先对<strong>n</strong>个记录的关键进行两两比较，然后在其 中的<strong>n/2</strong>个较小者之间再进行两两比较，如此重复，直至选出最小关键字的记录为止。</p>
</li>
<li><p><strong>堆排序</strong>：</p>
<ul>
<li><p>算法思路：</p>
<ul>
<li>对一组待排序列，首先把他们的关键字按照堆的定义排列成一个序列（建堆）</li>
<li>堆顶元素为最大值或者最小值，将堆顶元素输出</li>
<li>然后对剩余记录再次建堆，得到次最大/最小元素</li>
<li>如此反复进行，直到全部元素有序为止。</li>
</ul>
</li>
<li><p>如何建堆:</p>
<ul>
<li>把待排序记录存放在数组<strong>R[1..n]<strong>之中，将</strong>R</strong> 看作一棵二叉树，每个结点表示一个记录，将第一个记录<strong>R [1]<strong>作为二叉树的根，以下各记录</strong>R[2..n]<strong>依次逐层从左到右顺序排列，构成一棵完全二叉树，任意节点的左孩子时R[2i], 右孩子是R[2i  + 1], 双亲是R[i/2]。将待排序的所有记录放到一棵完全二叉树的各个结点中 (注意:这时的完全二叉树并不具备堆的特征)。此时所有</strong>i &gt;<strong>⎣</strong>n/2</strong>」的结点**R[i]<strong>是叶子结点，因此以</strong>R[i]**为根的子树已经 是堆。</li>
<li>从 <strong>i=</strong> ⎣<strong>n/2</strong>」的结点<strong>R[i]<strong>开始，比较根结点与左、右孩子的 关键字值，若根结点的值</strong>大于左、右孩子中的较小者</strong>，则交换根结点和值较小孩子的位置，即把根结点下移，然后根结点继续和新的孩子结点比较，如此一层一层地递归下去，直到根结点下移到某一位置时，它的左、右子结点的值都大于它的值或者已成为叶子结点。这个过程称为“筛选”。</li>
<li>从一个无序序列建堆的过程就是一个反复“筛选”的过程，“筛选”需要从<strong>i=<strong>⎣</strong>n/2</strong>」的结点<strong>R[i]<strong>开始，直至结点</strong>R[1]</strong> 结束。</li>
<li>对于已建好的堆，可以采用下面两个步骤进行排序<ul>
<li>输出栈顶元素：将栈顶元素与当前堆的最后一个元素对调</li>
<li>调整堆：将输出根节点之后的新的完全二叉树调整为堆</li>
<li>不断的输出栈顶元素，然后不断的将剩余的元素构建成堆，直到所有的记录都变成堆顶元素输出</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType &amp;H, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// 算法10.10 //一次筛选的实现</span></span><br><span class="line">	<span class="keyword">int</span> j; RedType rc; rc = H.r[s];</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">2</span>*s; j&lt;=m; j*=<span class="number">2</span>) &#123; <span class="comment">// 沿key较大的孩子结点向下筛选</span></span><br><span class="line">		<span class="keyword">if</span> (j&lt;m &amp;&amp; H.r[j].key&lt;H.r[j+<span class="number">1</span>].key) ++j; <span class="comment">//找左右孩子较大的值 </span></span><br><span class="line">    <span class="keyword">if</span> (rc.key &gt;= H.r[j].key) <span class="keyword">break</span>; <span class="comment">// rc应插入在位置s上 </span></span><br><span class="line">    H.r[s] = H.r[j]; s = j;</span><br><span class="line">  &#125;</span><br><span class="line">	H.r[s]=rc; <span class="comment">//插入 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(HeapType &amp;H)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; RedType temp;</span><br><span class="line">  <span class="keyword">for</span>(i=H.length/<span class="number">2</span>;i&gt;<span class="number">0</span>;--i) <span class="comment">//把H.r[1..H.length]建成大顶堆</span></span><br><span class="line">	  HeapAdjust(H, i, H.length); </span><br><span class="line">    <span class="keyword">for</span> (i=H.length; i&gt;<span class="number">1</span>; --i) &#123;</span><br><span class="line">      temp=H.r[i];</span><br><span class="line">      H.r[i]=H.r[<span class="number">1</span>];</span><br><span class="line">      H.r[<span class="number">1</span>]=temp; <span class="comment">//将堆顶记录和当前未经排序子序列Hr[1..i]中最后一个记录相互交换 </span></span><br><span class="line">      HeapAdjust(H,<span class="number">1</span>,i<span class="number">-1</span>); <span class="comment">//将H.r[1..i-1]重新调整为大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：建堆+排序= O(n) + O(nlog) = O(nlogn)</li>
<li>空间复杂度：O(1)</li>
<li>不稳定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>归并排序</strong>：</p>
<ul>
<li><p>设线性表R[low..m]，和R[m+1..high]是两个已排序的有 序表，存放在同一数组中相邻的位置上，将它们合并到一 个数组Rl中，合并过程如下:</p>
<ul>
<li>比较线性表R[low..m]与R[m+1..high]的第一个记录，将 其中关键字值较小的记录移入表R1(如果关键字值相同，可 将R[low..m]的第一个记录移入R1中)。</li>
<li>将关键字值较小的记录所在线性表的长度减1，并将其 后继记录作为该线性表的第一个记录。</li>
<li>反复执行上述过程，直到线性表R[low..m]或R[m+1..high] 之一成为空表，然后将非空表中剩余的记录移入R1中，此 时Rl成为一个有序表。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(RecodType SR[], ReordType TR[], <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]</span></span><br><span class="line">  <span class="keyword">int</span> j, k;</span><br><span class="line">  <span class="keyword">for</span> (j = m + <span class="number">1</span>; k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (SR[i].key &lt; SR[j].key) TR[k] = SR[i++];</span><br><span class="line">    <span class="keyword">else</span> TR[k] = SR[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= m) &#123;</span><br><span class="line">    <span class="keyword">while</span> (k&lt;=n &amp;&amp; i&lt;=m) TR[k++]=SR[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">while</span> (k&lt;=n &amp;&amp; j&lt;=n) TR[k++]=SR[j++];	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/10/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/" data-id="cks5t7etj0000al8nfeim9m6j" data-title="排序总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Iterprocess-Communication" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/02/Iterprocess-Communication/" class="article-date">
  <time class="dt-published" datetime="2021-08-02T11:04:49.000Z" itemprop="datePublished">2021-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/02/Iterprocess-Communication/">Iterprocess Communication</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="进程间通信IPC笔记整理"><a href="#进程间通信IPC笔记整理" class="headerlink" title="进程间通信IPC笔记整理"></a>进程间通信IPC笔记整理</h2><ul>
<li><p>概念： </p>
<ul>
<li>进程间通信是指不同进程之间传播或者交换信息。每个进程都有不同的<strong>用户地址空间</strong>，任何一个进程的全局变量在另一个进程中都看不到，因此进程间交换数据必须通过内核。</li>
<li>内核中开辟一块缓冲区，进程1把数据拷到内核缓冲区，进程2再从内核中把数据读走。</li>
</ul>
</li>
<li><p><strong>unix的进程通信方式：</strong></p>
<ul>
<li><strong>管道Pipe</strong>：<ul>
<li>半双工，单向流动，需要双方通信时，建立起两个管道</li>
<li>只能用于父子进程或者兄弟进程</li>
<li>可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数，要关闭管道只需将这两个文件描述符关闭即可。</li>
</ul>
</li>
<li><strong>命名管道FIFO</strong>：<ul>
<li>FIFO可以在<strong>无关的进程</strong>之间交换数据。</li>
<li>命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>
</ul>
</li>
<li><strong>信号（signal）</strong>：<ul>
<li>信号是比较复杂的通信方式，用于通知接受进程有某种事件发生</li>
<li>除了用于进程间通信外，进程还可以发送信号给进程本身</li>
</ul>
</li>
<li><strong>信号量</strong>：<ul>
<li>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li>
</ul>
</li>
<li><strong>共享内存（Shared Memory）</strong>：<ul>
<li>共享内存指两个或多个进程共享一个给定的存储区。</li>
<li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li>
<li>因为多个进程可以同时操作，所以需要进行同步。</li>
</ul>
</li>
<li><strong>消息队列（Message）</strong>：<ul>
<li>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</li>
<li>包括Posix消息队列system V消息队列</li>
<li>有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。</li>
<li>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等</li>
</ul>
</li>
<li><strong>内存映射（Mapped memory）</strong>：<ul>
<li>内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
</ul>
</li>
<li><strong>套接口（Socket）</strong>：<ul>
<li>更为一般的进程间通信机制，可用于不同机器之间的进程间通信。</li>
</ul>
</li>
</ul>
</li>
<li><p>补充：</p>
<ul>
<li><p><strong>fork的作用</strong>：调用fork(), 当控制转移到内核中的fork代码后，内核开始做：</p>
<ul>
<li>分配新的内存块和内核数据结构给子进程。</li>
<li>将父进程部分数据结构内容拷贝至子进程。</li>
<li>将子进程添加到系统进程列表。</li>
<li>fork返回开始调度器，调度。</li>
</ul>
</li>
<li><p><strong>用户空间和内核空间</strong></p>
<ul>
<li>操作系统采用的是<strong>虚拟地址空间</strong>，以32位操作系统举例，它的寻址空间为4G(2的32次方)<ul>
<li><strong>寻址</strong>：os能找到的地址范围</li>
<li><strong>虚拟地址空间</strong>：内存空间一共就4g，os为每一个进程都分配了4g，这个内存空间实际是虚拟的，虚拟到真实内存有个映射关系，例如<strong>段页式地址映射</strong>。</li>
</ul>
</li>
<li>os将这4g可访问的内存空间分为两部分，一部分为<strong>内核空间</strong>，另一部分为<strong>用户空间</strong>。<ul>
<li>内核空间：用于os内核访问的，独立于应用程序的，受保护的空间</li>
<li>用户空间：普通应用程序可以访问的空间</li>
</ul>
</li>
<li>每个进程可以通过系统调用进入内核，<strong>当进程/线程运行在内核空间时就处于内核态，而进程/线程运行在用户空间时则处于用户态。</strong></li>
<li>所有系统资源的管理都是在内存空间进行的，也就是在内核态去做的，应用程序需要访问磁盘，读取网卡的数据，新建一个线程都需要通过系统调用接口，完成从用户态到内存态的切换。</li>
<li>除了系统调用可以实现用户态到内核态的切换，还有软中断和硬中断。软中断是指进程发生了异常事件；硬中断就有很多种，例如时钟周期、IO等。</li>
</ul>
</li>
<li><p><strong>段页式地址映射</strong>：</p>
<ul>
<li><p><strong>段式虚拟内存</strong>：</p>
<ul>
<li>将整个内存空间，按照逻辑意义，划为若干个段。每段有段名，段的长度不固定。例如代码段，数据段，堆栈段。</li>
<li>地址的表示：<strong>虚拟地址（VA）= 段基地址（BA）+ 段内偏移量（S）</strong></li>
<li>每个进程的内存空间都是独立的，进程是隔离的，进程需要运行在物理内存上，但物理内存有限，无法为每个进程都分配4G的物理内存空间。为了解决该问题，需要将进程的虚拟内存<strong>按需</strong>加载到物理内存上。</li>
<li>缺点：用到某段的时候，就把整个段加载到内存上，会导致物理内存利用率低。</li>
</ul>
</li>
<li><p><strong>页式虚拟内存</strong>：</p>
<ul>
<li>将<strong>程序的内存空间</strong>分成一个个的页，每个页的大小相等（如1kB、2kB、4kB等）。</li>
<li>物理内存空间同样按照同样大小的页组织起来。进程页可以直接<strong>映射</strong>到物理内存页上面。</li>
<li><strong>虚拟内存地址（VA） = 页面基地址（BA）+ 页内偏移（S）= 页号（P）* 页大小（pSize） + 页内偏移（S）</strong></li>
</ul>
</li>
<li><p><strong>页的管理和映射</strong>：</p>
<ul>
<li><p>内存按照4kB大小的页进行管理， 4GB内存可以分为：4GB/4kB = 1M个页，</p>
</li>
<li><p>这一个个索引组成了一张索引表，称为<strong>页表</strong>，页表存储内容是<strong>内存页所在的页框号（物理内存的页号）</strong>因此一条记录需要4byte长度，即需要1M * 4 = 4MB内存来存储页表。</p>
</li>
<li><p>一个进程就需要4M内存放页表，则需要占用大量的内存，可以把1M个纪录分成：1M = 1024 x 1024来管理。 </p>
</li>
<li><p>线性地址的偏移量和物理地址的偏移量是相同的，映射主要是将线性地址的高20位映射到物理地址的可用页面上。</p>
<p><img src="https://img-blog.csdnimg.cn/20201022144414658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg0MDY2,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
</li>
</ul>
</li>
<li><p><strong>段的管理和映射</strong>：</p>
<ul>
<li><p>在os中，通过<strong>段描述符表</strong>来管理各个进程的段信息。</p>
</li>
<li><p>段描述符（8byte）：段基地址（4byte）+ 段限长（20bit）+段属性+段类型</p>
<p><img src="https://img-blog.csdnimg.cn/20201021162224453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg0MDY2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>段内偏移采用的是页式地址存放，段描述符表分为：全局描述符表（GDT），局部描述符表（LDT），中断描述符表（IDT）。</p>
<p><img src="https://img-blog.csdnimg.cn/2020102117161131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg0MDY2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>异步通信</strong>：异步通信在发送字符时，所发送的字符之间的时隙可以是任意的，当然，接收端必须时刻做好接收的准备。 </p>
</li>
<li><p><strong>同步通信</strong>：进行数据传输时，发送和接收双方要保持完全的同步（同频同相的同步时钟信号），因此，要求接收和发送设备必须使用同一时钟。</p>
</li>
<li><p><strong>时钟信号Clock Signal</strong>：用于决定逻辑单元中的状态何时更新，是有固定周期并与运行无关的信号量。 时钟信号有固定的时钟频率，时钟频率是时钟周期的倒数。由时钟发生器产生。</p>
</li>
<li><p><strong>时序逻辑电路</strong>：</p>
<ul>
<li>时序逻辑电路在逻辑功能上的特点是任意时刻的输出不仅取决于当时的输入信号，而且还取决于电路原来的状态，或者说，还与以前的输入有关。主要由存储电路和组合逻辑电路两部分组成， 存储电路可以将其输出状态保持住。</li>
<li><strong>两种存储电路</strong>：<strong>锁存器（latch）和触发器（flip-flop）</strong>，其两者的区别在于其输出状态的变化是否取决于CP（时钟脉冲Clock Pulse）</li>
<li>三种逻辑元器件：<ul>
<li><strong>计数器</strong>：主要由触发器组成，用于统计输入计数脉冲cp的个数。</li>
<li><strong>寄存器</strong>：寄存器是存放数码、运算结果或指令的电路, 移位寄存器不但可存放数码,而且在移位脉冲作用下,寄存器中的数码可根据需要向左或向右移位。一个触发器可存储一位二进制代码, n个触发器可存储n位二进制代码。</li>
<li><strong>顺序脉冲发生器</strong>：顺序脉冲是指在每个循环周期内,在时间上按一定先后顺序排列的脉冲信号。产生顺序脉冲信号的电路称为顺序脉冲发生器。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>组合逻辑电路</strong>：</p>
<ul>
<li>数字电路分为组合逻辑电路和时序逻辑电路</li>
<li>组合逻辑电路的特点是任意时刻的输出仅仅取决于该时刻的输入，与原来电路的状态无关。<ul>
<li>输入输出之间没有反馈延迟通道</li>
<li>电路中没有记忆化单元</li>
<li>常用组合逻辑电路：<ul>
<li>半加器和全加器：两个数A、B相加，只求本位之和，暂不管低位送来的进位数，称之为“半加”， 完成半加功能的逻辑电路叫半加器。。两数相加，不仅考虑本位之和，而且也考虑低位来的进位数，称为“全加”。实现这一功能的逻辑电路叫全加器。</li>
<li>加法器：实现多位二进制数相加的电路称为加法器。根据进位方式不同，有串行进位加法器和超前进位加法器两种<ul>
<li>串行进位加法器：最高位的计算，必须等到所有低位依此运算结束，送来进位信号之后才能进行。</li>
<li>超前进位加法器：所谓超前进位，就是在作加法运算时，各位数的进位信号由输入的二进制数直接产生</li>
</ul>
</li>
<li>编码器：用代码表示特定信号的过程称为编码，实现编码功能的逻辑电路称为编码器， 编码器的</li>
<li>译码器：把二进制代码转换成相应的输出信号的过程叫做译码，完成译码功能的逻辑电路叫做译码器。</li>
<li>数据选择器</li>
<li>数据分配器</li>
<li>数值比较器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>===========</p>
<p>参考文献<br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/2083023">https://baike.baidu.com/item/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/2083023</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/2083647">https://baike.baidu.com/item/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/2083647</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/2273903">https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/2273903</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343597285">https://zhuanlan.zhihu.com/p/343597285</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37984066/article/details/109199862">https://blog.csdn.net/m0_37984066/article/details/109199862</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40853073/article/details/81873398">https://blog.csdn.net/weixin_40853073/article/details/81873398</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zgq0/p/8780893.html">https://www.cnblogs.com/zgq0/p/8780893.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/02/Iterprocess-Communication/" data-id="ckruok1g50000op8n0sn4e9fl" data-title="Iterprocess Communication" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hash简介" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/02/hash%E7%AE%80%E4%BB%8B/" class="article-date">
  <time class="dt-published" datetime="2021-08-02T10:41:25.000Z" itemprop="datePublished">2021-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/02/hash%E7%AE%80%E4%BB%8B/">hash简介</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Hash简介"><a href="#Hash简介" class="headerlink" title="Hash简介"></a>Hash简介</h2><ul>
<li><strong>背景问题</strong>： 顺序存储的结构类型需要一个一个地按顺序访问元素。要查找某个对象时，只能以某种顺序（如顺序查找和二分查找）与各个元素进行比较。当元素数量很多时，查找的效率会明显降低。</li>
<li><strong>哈希算法</strong>：<ul>
<li>主要思想：根据结点的关键字的值确定其存储地址（key-index）</li>
<li>存储：以关键字K为自变量，通过一定的函数关系h(K)，计算出函数值并将其作为结点的存储地址，然后将结点存储到此存储单元中。</li>
<li>检索：以同样的方法计算地址，然后到该地址中取出结点。</li>
</ul>
</li>
<li><strong>哈希表（hash table）</strong>：<ul>
<li>定义：按哈希方法构造的存储结构称为哈希表（通过给定的关键字的值直接访问到具体对应的值的一个数据结构）也就是说，把关键字映射到一个表中的位置来直接访问记录，以加快访问速度。</li>
<li>通常我们把这个关键字称为 Key，把对应的记录称为 Value，所以也可以说是通过 Key 访问一个映射表来得到 Value 的地址。而这个映射表，也叫作散列函数或者哈希函数，存放记录的数组叫作散列表。</li>
</ul>
</li>
<li><strong>哈希函数（hash function）</strong>：数据元素的存放位置和数据元素的关键字之间建立起某种对应关系，建立这种对应关系的函数称为哈希函数。<ul>
<li>哈希函数的实现方法：<ul>
<li>考虑因素：关键字的长度，哈希表的大小，关键字的分布情况，记录的查找频率</li>
<li>几种实现方法：<ul>
<li><strong>直接寻址法</strong>：取关键字或者关键字的线性函数的值作为地址</li>
<li><strong>数字分析法</strong>：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</li>
<li><strong>平方取中法</strong>：当无法确定关键字哪几位较为均匀时，可以先求出关键字的平方值，然后按照需要取平方值的中间几位作为地址。因为平方值的中间几位与关键字的每一位都相关，所以产生不同的地址值的概率较高</li>
<li><strong>取随机数法</strong>：使用一个随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合</li>
<li><strong>除留取余法</strong>：设散列表长为n，取关键字被某个数m（m不大于n）除后得到的余数p为散列地址。该函数对 m 的选择很重要，一般取素数或者直接用 n。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>解决哈希冲突的方法</strong><ul>
<li>哈希冲突：不同的关键字经过哈希函数之后有可能得到相同的地址</li>
<li>几种处理方法： <ul>
<li><strong>开放寻址法</strong>：对计算出的地址进行一个探测再哈希，比如往后移动一个地址，如果没被占用，就用这个地址。如果超过最大长度，可以对总长度进行取余。</li>
<li><strong>再哈希法</strong>：使用关键字的其他部分继续计算地址，如还是有冲突，则继续使用其他部分哈希，缺点为增加了时间。</li>
<li><strong>链地址法</strong>：哈希之后落在了同一个地址上，在这个地址上做一个链表。</li>
<li><strong>建立公共溢出区</strong>：建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>================</p>
<p> 参考文献：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_59966683/article/details/118905196">https://blog.csdn.net/weixin_59966683/article/details/118905196</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f9239c9377c5">https://www.jianshu.com/p/f9239c9377c5</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005">https://zhuanlan.zhihu.com/p/63142005</a></p>
<p><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/107.html">http://data.biancheng.net/view/107.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/02/hash%E7%AE%80%E4%BB%8B/" data-id="ckruijsg70000ii8naaldh6oa" data-title="hash简介" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-自动化测试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/31/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2021-07-31T10:16:54.000Z" itemprop="datePublished">2021-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/31/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="自动化测试的总结"><a href="#自动化测试的总结" class="headerlink" title="自动化测试的总结"></a>自动化测试的总结</h2><ol>
<li><p>定义：</p>
<ul>
<li>自动测试就是用程序代替人的手工操作，完成一系列测试的过程。</li>
<li>自动打开程序，执行测试用例，查找控件，产生数据，输入数据，操作控件，收集结果，比较结果和期望。</li>
</ul>
</li>
<li><p>为什么？</p>
<ul>
<li>软件测试的工作量巨大且包含大量重复操作</li>
<li>很多情况下手工测试难以贴近真实环境且无法提供准确结果</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>可重复执行，且执行更多，更频繁的测试</li>
<li>可执行一些手动测试比较困难或不可能进行的测试</li>
<li>能更好的利用资源</li>
<li>具有一致性的特点</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>不能完全代替人工测试，不是所有的测试用例都可以自动化，工具本身不具备思维能力。</li>
<li>不能保证100%的测试覆盖率</li>
<li>需要更长的时间去分析和隔离所发现的缺陷</li>
</ul>
</li>
</ol>
<p>=========</p>
<p>参考文献</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37908248/article/details/113337238">https://blog.csdn.net/qq_37908248/article/details/113337238</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/31/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" data-id="ckrrmnlnl0000xyjc7t1aak2j" data-title="自动化测试" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-防火墙" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/31/%E9%98%B2%E7%81%AB%E5%A2%99/" class="article-date">
  <time class="dt-published" datetime="2021-07-31T08:02:59.000Z" itemprop="datePublished">2021-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/31/%E9%98%B2%E7%81%AB%E5%A2%99/">防火墙</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ol>
<li><strong>基本定义</strong><ul>
<li>一种将<strong>内部网和公共访问网（如internet）隔离开的方法</strong>。主要是借助硬件和软件的作用于内部和外部网络的环境间产生一种保护的屏障，从而实现对计算机不安全网络因素的阻断。 </li>
<li>防火墙技术的功能主要在于及时发现并处理计算机网络运行时可能存在的<strong>安全风险、数据传输</strong>等问题，其中处理措施包括<strong>隔离与保护</strong>，同时可对计算机网络安全当中的<strong>各项操作实施记录与检测</strong>，<strong>以确保计算机网络运行的安全性，保障用户资料与信息的完整性</strong>，为用户提供更好、更安全的计算机网络使用体验。</li>
</ul>
</li>
<li>功能 ：<ul>
<li>防火墙对网络通讯进行扫描，过滤掉一定的攻击，以免在目标计算机上执行。</li>
<li>防火墙还可以关闭不使用的端口，禁止特定的端口流出通信。</li>
<li>可以禁止来自特殊站点的访问，从而防止不明入侵者的通信。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/31/%E9%98%B2%E7%81%AB%E5%A2%99/" data-id="ckrrklosw0000idjc9fqgf2ps" data-title="防火墙" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C-S-and-B-S" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/31/C-S-and-B-S/" class="article-date">
  <time class="dt-published" datetime="2021-07-30T17:42:45.000Z" itemprop="datePublished">2021-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/31/C-S-and-B-S/">C/S and B/S</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="B-S-Browser-Server-vs-C-S-Client-Server-总结"><a href="#B-S-Browser-Server-vs-C-S-Client-Server-总结" class="headerlink" title="B/S (Browser/Server) vs C/S (Client/Server) 总结"></a>B/S (Browser/Server) vs C/S (Client/Server) 总结</h2><ol>
<li>B/S 即浏览器和服务器间结构</li>
</ol>
<ul>
<li>只安装维护一个服务器，而客户端采用浏览器运行软件。例如网页游戏。</li>
<li>优点：<ul>
<li>分布性强，可以随时进行查询，浏览等业务。</li>
<li>拓展性强，通过增加网页即可增加服务器功能</li>
<li>维护简单方便，需要改变网页，即可实现所有用户的同步更新。</li>
<li>开发简单，共享性强</li>
</ul>
</li>
<li>缺点： <ul>
<li>个性化特点降低，无法满足个性化的功能需求</li>
<li>功能弱化，难以实现传统模式下的特殊功能</li>
<li>响应速度降低，无法实现分页显示</li>
</ul>
</li>
</ul>
<ol start="2">
<li>C/S 即客户端与服务器结构</li>
</ol>
<ul>
<li>服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。例如需要下载客户端的游戏。</li>
<li>优点： <ul>
<li>可以借助客户端pc的处理能力，经客户端处理后再提交给服务器，响应速度快。</li>
<li>操作界面漂亮，形式多样，可充分满足客户个性需求</li>
<li>具有较强的业务处理能力，能处理复杂的业务</li>
<li>安全性很容易得到保证，提供了更安全的存取模式</li>
</ul>
</li>
<li>缺点：<ul>
<li>分布性弱，需要安装专门的客户端程序</li>
<li>兼容性差，对不同的开发工具，具有较大的局限性</li>
<li>开发维护成本高，发生一次升级，则所有客户端的程序都需要改变</li>
<li>用户群体固定，不适合面向一些未知用户，所以通用性较弱，通常用于局域网中。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>总结： </li>
</ol>
<ul>
<li>C/S 响应快，安全性强，一般只用于局域网中，但是维护开发成本高。</li>
<li>B/S 可以实现跨平台，客户端零维护，但是个性化能力差，响应速度慢。</li>
<li>所以一般日常办公应用使用B/S，实际生产中使用C/S。</li>
</ul>
<p>参考文献</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyx110/p/11232105.html">https://www.cnblogs.com/zyx110/p/11232105.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/322195626.html">https://zhidao.baidu.com/question/322195626.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/31/C-S-and-B-S/" data-id="ckrqmyf7y0000szjcgzs43za0" data-title="C/S and B/S" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/31/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-07-30T17:30:50.403Z" itemprop="datePublished">2021-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/31/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/31/hello-world/" data-id="ckrqmyf870001szjca3jd7cw6" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%B2/">数据结构学习笔记-串</a>
          </li>
        
          <li>
            <a href="/2021/08/10/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/">排序总结</a>
          </li>
        
          <li>
            <a href="/2021/08/02/Iterprocess-Communication/">Iterprocess Communication</a>
          </li>
        
          <li>
            <a href="/2021/08/02/hash%E7%AE%80%E4%BB%8B/">hash简介</a>
          </li>
        
          <li>
            <a href="/2021/07/31/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>